<#
.SYNOPSIS
   Constructs and emits a "PSServiceDefinition" object. Code used to generate
   this object can be written to file and consumed by PSService Install and
   Uninstall cmdlets.
.EXAMPLE
   $params = @{
     ServiceName        = "TestService"
     ServiceDescription = "This is a test service."

     ProcessOnTimer     = $true
   }

   $params.Begin = {
     Write-Log "Written from Begin."
   }
   $params.Process = {
     Write-Log "Written from Process."
   }
   $params.End = {
     Write-Log "Written from End."
   }

   New-PSServiceDefinition @params
.NOTES
   Given the high ceiling of complexity for configurations leveraging this
   cmdlet, it's highly advisable to use hashtables/splatting rather than
   specify parameters in-line.
.NOTES
   In the Begin, Process, and End script contexts, the ErrorActionPreference
   is configured to force exception to prevent unlogged errors.

   Function Write-Log is available in all contexts, should the service need to
   log its activity.

   Variable $service with property DataPath is available in all contexts,
   should the service need to persist data to the FileSystem.

   In the Process script context, variable $trigger is available with property
   Source -- whether the iteration was generated by Timer or (pipe) Message,
   and additional source-specific data. If $trigger.Source -eq "Message", for
   example, $trigger.Message will contain the message content.
.OUTPUTS
   System.Management.Automation.PSCustomObject w/ PSTypeName "PSServiceDefinition"
#>
function New-PSServiceDefinition {
  [CmdletBinding(
    DefaultParameterSetName = "UseServiceAccount",
    PositionalBinding = $false
  )]
  param(
    # The Name used by the service.
    [Parameter(
      Mandatory = $true
    )]
    [string]
    $ServiceName,

    # The DisplayName of the service. Defaults to Service.Name if not specified.
    [string]
    $ServiceDisplayName,

    # The Description of the service.
    [Parameter(
      Mandatory = $true
    )]
    [string]
    $ServiceDescription,

    # The authority by which the service runs. Each of these are wrinkles on
    # the system running the service by its own authority, and therefore do
    # not need a password. The default, "LocalSystem" (NT AUTHORITY\System),
    # exercises full local administrative rights, and full network authority
    # as granted by the Domain.
    [Parameter(
      ParameterSetName = "UseServiceAccount"
    )]
    [ValidateSet("LocalSystem", "LocalService", "NetworkService")]
    [string]
    $ServiceAccount = "LocalSystem",

    # The authority ([Domain]\User & Password) by which the service runs.
    [Parameter(
      ParameterSetName = "UseUserAccount",
      Mandatory        = $true
    )]
    [pscredential]
    $Credential,

    # The StartupType (StartMode) of the service.    
    [System.ServiceProcess.ServiceStartMode]
    $StartupType = [System.ServiceProcess.ServiceStartMode]::Automatic,

    # Whether to automatically start the service after install. Defaults to
    # False if StartupType is Manual or Disabled, True otherwise.
    [switch]
    $AutoStart,

    # The folder path to which the static service files (executable, service
    # definition, and README) will be written.
    #
    # Defaults to %ProgramFiles%\PSServiceManager\ServiceName
    [string]
    $InstallPath,

    # Whether to write the service definition as embedded in the executable to
    # the InstallPath.
    [switch]
    $SourceIsAvailable,

    # The folder path where working data used by the service will reside.
    #
    # Defaults to %ProgramData%\PSServiceManager\ServiceName
    [string]
    $DataPath,

    # The folder path where the service log will be written.
    #
    # Defaults to $DataPath\Logs
    [string]
    $LogPath,

    # Code to run *once* as the service starts. See cmdlet notes for more
    # details of execution context.
    [scriptblock]
    $Begin,

    # Code to run multiple times, as triggered by timer and/or control messages
    # via named pipe. See cmdlet notes for more details of execution context.
    [Parameter(
      Mandatory = $true
    )]
    [scriptblock]
    $Process,

    # Code to run *once* as the service ends. See cmdlet notes for more details
    # of execution context.
    [scriptblock]
    $End,

    # Whether to execute the Process block on a recurring timer.
    [switch]
    $ProcessOnTimer,

    # The duration in milliseconds of the timer by which the Process block is
    # run.
    [double]
    $TimerInterval = 1000,

    # Whether to execute the Process block on receipt of control messages via
    # named pipe.
    [switch]
    $ProcessOnMessage,

    # Identities (e.g. accounts/groups) allowed to send control messages to the
    # service via named pipe.
    [string[]]
    $MessageWriteAccess
  )

  $outObj = [PSCustomObject]@{
    PSTypeName           = "PSServiceDefinition"
    ServiceName          = $ServiceName
    ServiceDisplayName   = $ServiceDisplayName
    ServiceDescription   = $ServiceDescription
    Credential           = $Credential
    StartupType          = $StartupType
    AutoStart            = if ($PSBoundParameters.ContainsKey("AutoStart")) {$AutoStart} else {$StartupType -notin @([System.ServiceProcess.ServiceStartMode]::Manual, [System.ServiceProcess.ServiceStartMode]::Disabled)}
    InstallPath          = $InstallPath
    SourceIsAvailable    = (-not $PSBoundParameters.ContainsKey("SourceIsAvailable")) -or $SourceIsAvailable
    DataPath             = $DataPath
    LogPath              = $LogPath
    Begin                = [string]$Begin
    Process              = [string]$Process
    End                  = [string]$End
    ProcessOnTimer       = [bool]$ProcessOnInterval
    TimerInterval        = $TimerInterval
    ProcessOnMessage     = [bool]$ProcessOnMessage
    MessageWriteAccess   = $MessageWriteAccess
  }

  if ($ServiceDisplayName.Length -eq 0) {
    $outObj.ServiceDisplayName = $ServiceName
  }

  if ($null -eq $Credential) {
    $outObj.Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList @(
      "NT AUTHORITY\$(if ($ServiceAccount -eq "LocalSystem") {"System"} else {$ServiceAccount})"
      New-Object -TypeName System.Security.SecureString # Empty
    )
  }

  if ($InstallPath.Length -eq 0) {
    $outObj.InstallPath = "$env:ProgramFiles\PSServiceManager\$ServiceName"
  }

  if ($DataPath.Length -eq 0) {
    $outObj.DataPath = "$env:ProgramData\PSServiceManager\$ServiceName"
  }

  if ($LogPath.Length -eq 0) {
    $outObj.LogPath = Join-Path -Path $outObj.DataPath -ChildPath Logs
  }

  $outObj
}